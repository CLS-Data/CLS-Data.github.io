---
layout: default
title: "A Primer on R"
nav_order: 2
format: docusaurus-md
---

# Introduction

In this page we provide a brief primer on the `R` programming language and the packages we use in the tutorials - notably, the `tidyverse`. We provide links to further resources on `R` and the `tidyverse` at the end of this page.

# `R` and the `tidyverse`
`R` is an open-source programming language and has a limited set of core functions installed as standard (collectively referred to a *Base R* after the `base` package). However, the functionality of `R` can be extended by installing and loading additional *packages*, which are developed by `R`'s very active, but decentralised, development community. As it is decentralised, the packages developers create often do not cohere or work well together - e.g., the objects produced by a function in one package may not straightforwardly input with the objects required by a function in another package.

The `tidyverse` addresses this problem. The `tidyverse` is an extremely useful collection of package for data cleaning, analysis, and visualization, and includes popular packages such as `dplyr`, `ggplot2`, `tidyr`, and `purrr`. But beyond this, it is also a design philosophy: function names are self-explanatory, arguments are consistently named and ordered, and the output of one function is designed to be easily input into another. As this design philosophy is public, other developers can (and do!) create packages that work well alongside it.

Two core features of the `tidyverse` are the extensive use of `tibbles` and the *pipe* (`%>%`). A `tibble` is a type a `data.frame` - a rectangular data structure, like a spreadsheet, with rows (observations) and columns (variables); many `tidyverse` functions expect a `tibble` (or `data.frame`) as the first input and output a `tibble` in turn. The pipe (`%>%`) is an operator that allows you to chain together multiple operations in a way that is easier to read and write. By default, the object or output of the function on the left hand side is "piped" into the first argument of the function of the right hand side (piping into other arguments can be achieved using the placeholder "`.`"). Below we load the `tidyverse`, and use the pipe with a few `dplyr` functions to clean and summarise the inbuilt `starwars` dataset.

```{r}
# install.packages("tidyverse") # Uncomment if you need to install
library(tidyverse)

starwars %>% 
  mutate(height_m = height / 100, 
         bmi = mass / (height_m ^ 2)) %>%
  drop_na(bmi) %>% 
  summarise(mean_bmi = mean(bmi), 
            min_bmi = min(bmi), 
            max_bmi = max(bmi))
```

Above, you will see that the `library(tidyverse)` command loads a set of packages, including `dplyr`, `readr` and `forcats`. These are the *core* `tidyverse` packages. `install.packages("tidyverse")` installs more packages than this - most notably, `haven` and `glue` - but these need to be loaded explicitly before use.

# `haven::read_dta()` and the `labelled` package
The CLS data is stored in Stata `.dta` files, and the `haven` package provides the `read_dta()` function to import these files into `R`. The `read_dta()` function is part of the `haven` package, which is part of the `tidyverse`. The `read_dta()` function is particularly useful as it imports the metadata from the Stata file, such as variable labels and value labels, and stores this information in the `labelled` class. This means that the metadata is retained when the data is imported into `R`, and can be accessed and used in subsequent data manipulation and analysis.

`lookfor`, `val_labels`, and `var_labels` are functions from the `labelled` package that allow you to access the value labels and variable labels stored in the metadata of a `labelled` object. Below we import the `mcs2_cm_interview.dta` file and use the `lookfor()` function to find the variable labels for the `MCSID` and `CNUM00` variables.

# Functions for Data Munging
## select/rename, mutate/summarise, filter, group_by()
# tidyselect, stringr and Regular Expressions, pick()
# `glue()`
# Repeating Yourself: Anonymous functions, across, map, and rename_with
# Reshaping
# Mutating and Filtering Joins


In this tutorial, we will learn how to reshape data from long to wide (and vice versa) using the `tidyverse` package in `R`. We will use data on cohort member's height and weight collected in Sweeps 2-7 to demonstrate the process.

```{r}
#| warning: false
# Load Packages
library(tidyverse) # For data manipulation
library(haven) # For importing .dta files
library(glue) # For creating strings
```

```{r}
#| include: false
# setwd(Sys.getenv("mcs_fld"))
```

# Reshaping from Wide to Long

We begin by loading the data from each sweep and merging these together into a single wide format data frame; see [Combining Data Across Sweeps](https://cls-data.github.io/docs/mcs-merging_across_sweeps.html) for more details. Note, the names of the height and weight variables in Sweep 5 (`ECHTCMA0` and `ECWTCMAO`) diverge slightly from the rubric used for other sweeps (`[A-G]CHTCM00` and `[A-G]CWTCM00` where `[A-G]` denotes sweep), hence the need for the complex regular expression in `read_dta(col_select = ...)` function call. To simplify the names of the columns in the wide dataset, we rename the Sweep 5 variables so they follow the rubric for Sweeps 2-4 and 6-7.

```{r}
fups <- c(0, 3, 5, 7, 11, 14, 17)

load_height_wide <- function(sweep){
  fup <- fups[sweep]
  prefix <- LETTERS[sweep]
  
  glue("{fup}y/mcs{sweep}_cm_interview.dta") %>%
    read_dta(col_select = c("MCSID", matches("^.(CNUM00|CHTCM(A|0)0)"))) %>%
    rename(cnum = matches("CNUM00"))
}

df_wide <- map(2:7, load_height_wide) %>%
  reduce(~ full_join(.x, .y, by = c("MCSID", "cnum"))) %>%
  rename(ECHTCM00 = ECHTCMA0, ECWTCMA00 = ECWTCMA0)

str(df_wide)
```

`df_wide` has 14 columns. Besides, the identifiers, `MCSID` and `cnum`, there are 12 columns for height and weight measurements at each sweep. Each of these 12 columns is prefixed by a single letter indicating the sweep. We can reshape the dataset into long format (one row per person x sweep combination) using the `pivot_longer()` function so that the resulting data frame has five columns: two person identifiers, a variable for sweep, and variables for height and weight. We specify the columns to be reshaped using the `cols` argument, provide the new variable names in the `names_to` argument, and the pattern the existing column names take using the `names_pattern` argument. For `names_pattern` we specify `"(.)(.*)"`, which breaks the column name into two pieces: the first character (`"(.)"`) and the rest of the name (`"(.*)"`). As noted, the first character holds information on sweep. In `names_to`, `.value` is a placeholder for the second piece of the column name.

```{r}
df_long <- df_wide %>%
  pivot_longer(cols = matches("C(H|W)TCM00"),
               names_to = c("sweep", ".value"),
               names_pattern = "(.)(.*)")

df_long
```

# Reshaping from Long to Wide
We can also reshape the data from long to wide format using the `pivot_wider()` function. In this case, we want to create two new columns for each sweep: one for height and one for weight. We specify the columns to be reshaped using the `values_from` argument, provide the new column names in the `names_from` argument, and use the `names_glue` argument to specify the new column names. The `names_glue` argument uses curly braces (`{}`) to reference the values from the `names_from` and `.value` arguments. As we are specifying multiple columns in `values_from`, `.value` is a placeholder for the variable name.

```{r}
df_long %>%
  pivot_wider(names_from = sweep,
              values_from = matches("C(W|H)T"),
              names_glue = "{sweep}{.value}")
```

# Reshape a Cleaned Dataset from Long to Wide
It is likely that you will not just need to reshape raw data, but cleaned data too. In the next two sections we offer advice on naming variables so that they are easy to select and reshape in long or wide formats. First, let's clean the long dataset by converting the `cnum` and `sweep` columns to integers, creating a new column for follow-up time, and creating new `height` and `weight` variables that replace negative values in the raw height and weight data with `NA` (as well as giving these variables more easy-to-understand names).


```{r}
df_long_clean <- df_long %>%
  mutate(cnum = as.integer(cnum),
         sweep = match(sweep, LETTERS),
         fup = fups[sweep],
         height = ifelse(CHTCM00 > 0, CHTCM00, NA),
         weight = ifelse(CWTCM00 > 0, CWTCM00, NA)) %>%
  select(MCSID, cnum, fup, height, weight)
```

To reshape the clean data from long to wide format, we can use the `pivot_wider()` function as before. This time, we specify the columns to be reshaped using the `names_from` argument, provide the new column names in the `values_from` argument, and use the `names_glue` argument to specify the new column names. The `names_glue` argument uses curly braces (`{}`) to reference the values from the `names_from` and `.value` arguments. As we are specifying multiple columns in `values_from`, `.value` is a placeholder for the variable name.


```{r}
df_wide_clean <- df_long_clean %>%
  pivot_wider(names_from = fup,
              values_from = c(height, weight),
              names_glue = "{.value}_{fup}y")

df_wide_clean
```

# Reshape a Cleaned Dataset from Long to Wide
Finally, we can reshape the clean wide dataset back to long format using the `pivot_longer()` function. We specify the columns to be reshaped using the `cols` argument, provide the new variable names in the `names_to` argument, and the pattern the existing column names take using the `names_pattern` argument. For `names_pattern` we specify `"(.*)_(.*)y"`, which breaks the column name into two pieces: the variable name (`"(.*)"`), and the follow-up time (`"(.*)y"`). We also use the `names_transform` argument to convert the follow-up time to an integer.

```{r}
df_wide_clean %>%
  pivot_longer(cols = matches("_.*y$"),
               names_to = c(".value", "fup"),
               names_pattern = "(.*)_(\\d+)y$",
               names_transform = list(fup = as.integer))
```
