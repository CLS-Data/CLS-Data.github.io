---
layout: default
title: "Combining Data Across Sweeps"
nav_order: 3
parent: NCDS
format: gfm
---

- [Download the R script for this page](../purl/ncds-merging_across_sweeps.R)
- [Download the equivalent Stata script for this page](../do_files/ncds-merging_across_sweeps.do)

# Introduction

In this section, we show how to combine NCDS data across sweeps.

As an example, we use data on cohort members' weight. These are contained in files which have one row per cohort-member. As a reminder, we have organised the data files so that each sweep [has its own folder, which is named according to the age of follow-up](https://cls-data.github.io/docs/ncds-sweep_folders.html) (e.g., 55y for the ninth major sweep).

We begin by combining data from the Sweeps 4 (23y) and Sweep 8 (50y), showing how to combine these datasets in **wide** (one row per observational unit) and **long** (multiple rows per observational unit) formats by *merging* and *appending*, respectively. Because variable names change between sweeps in unpredictable ways, it is not straightforwardly possible to combine data from multiple sweeps *programmatically* (as we are able to do for, e.g., the [MCS](https://cls-data.github.io/docs/mcs-merging_across_sweeps.html)).

We use the following packages:

```{r}
#| warning: false
# Load Packages
library(tidyverse) # For data manipulation
library(haven) # For importing .dta files
```

```{r}
#| include: false
# setwd(Sys.getenv("mcs_fld"))
```

# Merging Across Sweeps

The variables `dvwt23` and `DVWT50` contains the weight of the cohort member at Sweeps 4 (23y) and Sweep 8 (50y), respectively. Note, these are derived variable which convert raw weight measurements into kilograms. The variable names follow the same convention (with the exception that at age 23y, lower case is used). This bucks the more general case where conceptually similar variables have different (potentially, non-descriptive) names, when combining data including early sweeps. 

We will use the `read_dta()` function from `haven` to read in the data from the four sweeps, specifying the `col_select` argument to keep only the variables we need (the identifier and weight variables).

```{r}
df_23y <- read_dta("23y/ncds4.dta",
                      col_select = c("ncdsid", "dvwt23"))

df_50y <- read_dta("50y/ncds_2008_followup.dta",
                   col_select = c("NCDSID", "DVWT50"))
```

We can merge these datasets by row using the `*_join()` family of functions. These share a common syntax. They take two data frames (`x` and `y`) as arguments, as well as a `by` argument that specifies the variable(s) to join on. The `*_join()` functions are:

1.  `full_join()`: Returns all rows from `x` and `y`, and all columns from `x` and `y`. For rows without matches in both `x` and `y`, the missing value `NA` is used for columns that are not used as identifiers.
2.  `inner_join()`: Returns all rows from `x` and `y` where there are matching rows in both data frames.
3.  `left_join()`: Returns all rows from `x`, and all columns from `x` and `y`. Rows in `x` with no match in `y` will have `NA` values in the new columns from `y`.
4.  `right_join()`: Returns all rows from `y`, and all columns from `x` and `y`. Rows in `y` with no match in `x` will have `NA` values in the columns of `x`.

In the current context, where `x` is data from the Sweeps 4 (`df_23y`) and `y` is data from the 50y sweep (`df_50y`): `full_join()` will return a row for each individual present in the Sweep 4 or Sweep 8, with the weight from each sweep in the same row; `inner_join()` will return a row for each individual who was present in all these sweeps, with the weight from each sweep in the same row; `left_join()` will return a row for each individual in the fourth sweep, with the weight from the eighth sweep in the same row if the individual was present in the eighth sweep; `right_join()` will return a row for each individual in the eighth sweep, with the weight from the fourth sweep in the same row if the individual was present in the fourth sweep.

The `*_join()` functions can handle multiple variables to join on, and can also handle situations where the identifiers have different names across `x` and `y`. To specify the identifiers, we pass a vector to the `by` argument. In this case, we pass a *named vector* so that `ncdsid` in `df_23y` can be matched to `NCDSID` in `df_50y`.

```{r}
df_23y %>%
full_join(df_50y, by = c(ncdsid = "NCDSID"))

df_23y %>%
inner_join(df_50y, by = c(ncdsid = "NCDSID"))

df_23y %>%
left_join(df_50y, by = c(ncdsid = "NCDSID"))

df_23y %>%
right_join(df_50y, by = c(ncdsid = "NCDSID"))
```

Note, the `*_join()` functions will merge any matching rows. Unlike `Stata`, we do not have to explicitly state whether we want a 1-to-1, many-to-1, 1-to-many, or many-to-many merge. This is determined by the data that are inputted to `*_join()`.

When the `by = ...` isn't used explicitly, the `*_join()` will merge on any variables which have the same names across the two datasets. As `df_23y` has variables in lower case and `df_50y` has variables in upper case, we could have renamed the variables in `df_23y` in one fell swoop with `rename_with(str_to_upper)`. There are usually many ways of achieving the same thing.

```{r}
df_23y %>%
rename_with(str_to_upper) %>% # Converts all variable names to upper case
full_join(df_50y)
```

# Appending Sweeps

To put the data into long format, we can use the `bind_rows()` function. (In this case, the data will have one row per cohort-member x sweep combination.) To work properly, we need to name the variables consistently across sweeps, which here means removing the age-specific suffixes (e.g., the number `23` from `dvwt23` in `df_3y`). We also need to add a variable to identify the sweep the data comes from. Below, we use the `mutate()` function to create a `sweep` variable and then use the `rename_with()` function to remove the suffixes and rename the variables consistently across sweeps. (Given we only had one variable to rename, we could have done this manually with `rename()`, but this approach is more scalable.)

```{r}
df_23y_nosuffix <- df_23y %>%
rename_with(str_to_upper) %>%
rename_with(~ str_remove(.x, "23$")) %>%  # Removes the suffix '23' from variable names
mutate(sweep = 23, .before = 1)

df_50y_nosuffix <- df_50y %>%
rename_with(~ str_remove(.x, "50$")) %>%
mutate(sweep = 50, .before = 1)
```

`rename_with()` applies a function to the names of the variables. In this case, we use the `str_remove()` function from the `stringr` package (part of the `tidyverse`) to remove the suffix from the variable names. The `~` symbol is used to create an [*anonymous function*](https://r4ds.hadley.nz/iteration.html), which is applied to each variable name. The `.x` symbol in the anonymous function is a placeholder for the variable name. `str_remove()` takes a regular expression. The `$` symbol is used to match the end of the string (so `23$` removes the `23` where it is the last characters in a variable name). Note, for the `mutate()` call, the `.before` argument is used to specify the position of the new variable in the data frame - here we specify `sweep` as the first column. Below we see what the formatted data frames look like:

```{r}
df_23y_nosuffix
df_50y_nosuffix
```

Now the data have been prepared, we can use `bind_rows()` to append the data frames together. This will stack the data frames on top of each other, so the number of rows is equal to the sum of rows in the individual datasets. The `bind_rows()` function can handle data frames with different numbers of columns. Missing columns are filled with `NA` values.

```{r}
bind_rows(df_23y_nosuffix, df_50y_nosuffix) %>%
arrange(NCDSID, sweep) # Sorts the dataset by ID and sweep
```

Notice that with `bind_rows()` a cohort member has only as many rows of data as the times they appeared in Sweeps 4 and 8. This differs from `*_join()` where an explicit missing `NA` value is generated for the missing sweep. The `tidyverse` function `complete()` [can be used to create missing rows](https://r4ds.hadley.nz/missing-values.html#sec-missing-implicit), which can be useful if you need to generate a balanced panel of observations from which to begin analysis with (e.g., when performing multiple imputation in long format).

```{r}
bind_rows(df_23y_nosuffix, df_50y_nosuffix) %>%
complete(NCDSID, sweep) %>% # Ensure cohort members have a row for each sweep
arrange(NCDSID, sweep) 
```
